generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id              Int       @id @default(autoincrement())
  email           String    @unique
  name            String
  password        String
  profile         String?
  birthday        DateTime?
  country         String?
  phoneNumber     String?
  profileVisible  Boolean   @default(true)
  isAdmin         Boolean   @default(false)
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt @default(now()) 

  groups             Group[]
  deviceTokens       DeviceToken[]
  deviceAuthRequests DeviceAuthRequest[]
  notifications      Notification[]
  sentTickets        SupportTicket[]      @relation("TicketSender")
  assignedTickets    SupportTicket[]      @relation("TicketAssignee")
  ticketReplies      TicketReply[]
}

model Group {
  id          String   @id @default(uuid())
  name        String
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  cards       Card[]
  userId      Int
  user        User     @relation(fields: [userId], references: [id])
  
  // Nested groups support
  parentId  String?
  parent    Group?   @relation("GroupHierarchy", fields: [parentId], references: [id], onDelete: Cascade)
  children  Group[]  @relation("GroupHierarchy")
  
  // Public group fields
  isPublic    Boolean  @default(false)
  language    String?
  tags        String[] @default([])
  
  // Reference to original group (for copies)
  originalGroupId String?
  
  @@unique([userId, name, parentId])
  @@unique([userId, originalGroupId]) // Prevent adding same public group twice
  @@index([name])
  @@index([parentId])
  @@index([isPublic])
}
enum ContentType {
  TEXT
  AUDIO
  VIDEO
  IMAGE
}

enum ReviewResponse {
  AGAIN
  HARD
  EASY
}

model Card {
  id          Int         @id @default(autoincrement())
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  groupId     String
  group       Group       @relation(fields: [groupId], references: [id], onDelete: Cascade)
  
  // Question side
  questionText     String?
  questionType     ContentType @default(TEXT)
  questionMediaUrl String?
  
  // Answer side
  answerText       String?
  answerType       ContentType @default(TEXT)
  answerMediaUrl   String?
  
  // Spaced repetition fields
  nextReviewAt     DateTime    @default(now())
  interval         Int         @default(0)      // days until next review
  easeFactor       Float       @default(2.5)    // multiplier for interval
  repetitions      Int         @default(0)      // number of successful reviews
  
  reviews          CardReview[]

  @@index([groupId])
  @@index([nextReviewAt])
}

model CardReview {
  id         Int            @id @default(autoincrement())
  cardId     Int
  card       Card           @relation(fields: [cardId], references: [id], onDelete: Cascade)
  response   ReviewResponse
  reviewedAt DateTime       @default(now())
  
  @@index([cardId])
}


model Message {
  id        Int      @id @default(autoincrement())
  message   String
  createdAt DateTime @default(now())
}

model DeviceToken {
  id           String   @id @default(uuid())
  userId       Int
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  deviceName   String   @default("Python CLI")
  accessToken  String   @unique
  createdAt    DateTime @default(now())
  lastUsedAt   DateTime @default(now())
  expiresAt    DateTime?
  revoked      Boolean  @default(false)

  @@index([userId])
  @@index([accessToken])
}

model DeviceAuthRequest {
  id           String   @id @default(uuid())
  deviceCode   String   @unique
  userCode     String   @unique
  deviceName   String   @default("Python CLI")
  expiresAt    DateTime
  authorizedAt DateTime?
  userId       Int?
  user         User?    @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken  String?

  @@index([deviceCode])
  @@index([userCode])
}

// Notification system
enum NotificationType {
  GROUP_SHARED
  TICKET_REPLY
  SYSTEM
}

model Notification {
  id        String           @id @default(uuid())
  userId    Int
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  type      NotificationType
  title     String
  message   String
  read      Boolean          @default(false)
  data      Json?            // Extra data like groupId, ticketId, etc.
  createdAt DateTime         @default(now())

  @@index([userId])
  @@index([read])
}

// Support ticket system
enum TicketStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
  CLOSED
}

enum TicketPriority {
  LOW
  MEDIUM
  HIGH
}

model SupportTicket {
  id          String         @id @default(uuid())
  subject     String
  description String
  status      TicketStatus   @default(OPEN)
  priority    TicketPriority @default(MEDIUM)
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
  
  // Sender (user who created the ticket)
  senderId    Int
  sender      User           @relation("TicketSender", fields: [senderId], references: [id], onDelete: Cascade)
  
  // Assignee (admin handling the ticket)
  assigneeId  Int?
  assignee    User?          @relation("TicketAssignee", fields: [assigneeId], references: [id])
  
  replies     TicketReply[]

  @@index([senderId])
  @@index([status])
}

model TicketReply {
  id        String   @id @default(uuid())
  ticketId  String
  ticket    SupportTicket @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  userId    Int
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  message   String
  createdAt DateTime @default(now())

  @@index([ticketId])
}

// Download tracking
model DownloadLog {
  id           String   @id @default(uuid())
  fileName     String
  userId       Int?
  ipAddress    String?
  userAgent    String?
  createdAt    DateTime @default(now())

  @@index([fileName])
  @@index([userId])
}
